<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.555">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>About Us - EPPS Math &amp; Coding Camp</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="about-us_files/libs/clipboard/clipboard.min.js"></script>
<script src="about-us_files/libs/quarto-html/quarto.js"></script>
<script src="about-us_files/libs/quarto-html/popper.min.js"></script>
<script src="about-us_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="about-us_files/libs/quarto-html/anchor.min.js"></script>
<link href="about-us_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="about-us_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="about-us_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="about-us_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="about-us_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


<link rel="stylesheet" href="styles.css">
</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">About Us - EPPS Math &amp; Coding Camp</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<header>
<a href="index.html" class="main-site-link">Back to Main Page</a>
</header>
<main>
<h1>
About Us
</h1>
<h2 class="anchored">
Meet the team behind the EPPS Math &amp; Coding Camp:
</h2>
<h2 class="anchored">
Prajyna Paramita Barua
</h2>
<p>
PhD Student, Economics
</p>
<p>
Prajyna Paramita Barua is currently pursuing her fifth year of Ph.D.&nbsp;in Economics from the University of Texas, Dallas. Her research interests lie in applied macroeconomics and labor economics, with a particular focus on their implications for monetary policy. Prajyna’s current research delves into the dynamics of the U.S. labor market from a macroeconomic perspective. Specifically, she is examining the trade-off between vacancies and unemployment in the U.S. labor market under time variation, and assessing labor market efficiency and inefficiencies through the lens of the unemployment gap. In addition to her research, Prajyna is also engaged in teaching Principles of Macroeconomics at the University of Texas, Dallas.
</p>
<h2 class="anchored">
Dohyo Jeong
</h2>
<p>
PhD student, Public Policy &amp; Political Economy
</p>
<p>
<a href="https://dohyojeong.github.io/" target="_blank">Website</a>
</p>
<img src="picture_dohyo_cc.jpg" alt="Dohyo Jeong" style="max-width: 200px; border-radius: 50%;">
<p>
Dohyo Jeong’s research focuses on identifying and addressing regional disparities in resource allocation within global public health systems, emphasizing public health crisis management, public health services planning, and the social impacts of epidemiology. He has researched geographic patterns of infectious diseases such as tuberculosis and access to treatment, revealing regional disparities that affect treatment outcomes. His work on emergency medical services (EMS) highlights the importance of demand forecasting and resource optimization using spatial-temporal machine learning techniques. Dohyo also explores the social impacts of public health crises, including the distribution of COVID-19 treatments, the influence of pandemics on education and crime patterns, and the role of social media in managing public hysteria. His future research aims to investigate disparities from regional and individual perspectives, utilizing causal inference, machine learning, and spatial statistics to enhance public health policy and reduce health disparities. At UT Dallas, Dohyo Jeong served as an instructor for the EPPS Math and Coding Camp (2024), taught the EPPS 2302 Methods of Quantitative Analysis in the Social and Policy Sciences course, and delivered various guest lectures.
</p>
<h2 class="anchored">
Azharul Islam
</h2>
<p>
PhD student, Economics
</p>
<p>
<a href="https://epps.utdallas.edu/phd-students/azharul-islam/" target="_blank">Website</a>
</p>
<img src="Headshot-Azharul.jpg" alt="Azharul Islam" style="max-width: 200px; border-radius: 50%;">
<p>
Azharul Islam is currently pursuing a Ph.D.&nbsp;in Economics at the School of Economic, Political, and Policy Sciences at UT Dallas. Prior to this, he earned a Master of Arts in Economics from Central Michigan University and Virginia Tech. Azharul’s research focuses on analyzing the impact of consumer sentiment on macroeconomic variables in the US, including GDP growth, unemployment, inflation expectations, and consumer price indices. He is also working on another independent project and three co-authored projects, all of which revolve around the common theme of inflation expectations within the context of the US macroeconomy. In addition to his research, Azharul teaches economics courses at UT Dallas as an instructor, where he relates economic theories to research findings to illustrate real economic phenomena. He is passionate about exploring the intersection of economics and policy, and aspires to make meaningful contributions to the macroeconomic field as an academic. Originally from Dhaka, Bangladesh, Azharul received his undergraduate degree in economics. Despite being physically separated by distance, he enjoys staying connected with his family members and relatives.
</p>
<h2 class="anchored">
Shreyas Meher
</h2>
<p>
PhD student, Public Policy &amp; Political Economy
</p>
<p>
<a href="https://shreyasmeher.com/" target="_blank">Website</a>
</p>
<img src="headshot.jpg" alt="Shreyas Meher" style="max-width: 200px; border-radius: 50%;">
<p>
Shreyas Meher is a PhD candidate in Public Policy &amp; Political Economy at the University of Texas at Dallas, specializing in the intersection of digital economics, political analysis, and computational linguistics. His research primarily focuses on internet censorship, cyber law and policy, and content moderation in democratic contexts. Shreyas employs advanced machine learning techniques, including Large Language Models, to analyze political and social event data. As a key contributor to an NSF-funded project, Shreyas works on applying cutting-edge ML technologies like ConfliBERT to revolutionize event data extraction in political science. His dissertation explores the nuanced approaches of democracies to internet control, the politics of internet blackouts in India, and the global impact of major tech companies’ decisions in authoritarian markets. Shreyas’s work spans comparative politics, digital governance, and the application of computational methods to policy questions. He has presented his research at major conferences like APSA and MPSA, and has papers under review in notable journals. With a background in economics and energy management, Shreyas brings a multidisciplinary approach to studying the complex interplay between politics, economics, and digital spaces. https://www.shreyasmeher.com
</p>
<h2 class="anchored">
Xingyuan Zhao
</h2>
<p>
PhD Student, Political Science
</p>
<p>
<a href="https://xing-yuan-zhao.github.io/bio/" target="_blank">Website</a>
</p>
<img src="photo1_mid.jpeg" alt="Xingyuan Zhao" style="max-width: 200px; border-radius: 50%;">
<p>
Xingyuan Zhao is a Ph.D.&nbsp;student in Political Science at the University of Texas at Dallas. His research focuses on leveraging Natural Language Processing (NLP) techniques to convert political text information into structured knowledge and derive meaningful insights. By leveraging cutting-edge NLP algorithms and domain expertise in political science, Xingyuan aims to uncover hidden patterns and trends in political discourse that can inform policy-making and enhance our understanding of complex political phenomena. His ultimate goal is to bridge the gap between advanced NLP technologies and real-world political applications, contributing to more data-driven and evidence-based decision-making in the public sector.
</p>
<h2 class="anchored">
Program Director: Dr.&nbsp;Karl Ho
</h2>
<p>
<a href="https://karlho.com/" target="_blank">Website</a>
</p>
<img src="ho-karl-800-2015-12-medium.jpg" alt="Dr. Karl Ho" style="max-width: 200px; border-radius: 50%;">
<p>
Karl Ho is a political scientist working at the intersection of data science and social science. His research interests span both domains of data analytics and political studies, with a regional focus on East Asia. The unifying theme of Karl’s research is to use data science methods to explain and prescribe social and political problems. Areas of research topics include democratization, political economy, public policy, and human rights, aiming at building public goods and improving policies, governance, and representation. As the Director of Graduate Studies in the University of Texas at Dallas (UTD) Political Science program, Karl oversees the graduate studies curriculum and is responsible for guiding students through their academic journey. He is also the founding faculty member of the UTD Social Data Analytics and Research Master’s program, where he leads a team of researchers in exploring the intersection of data science and social science. Additionally, Karl hosts the Data Analytics Colloquium, a joint project with the National Chung Hsing University, which brings together experts from various fields to share their research findings and insights on the applications of data analytics.
</p>
</main>
<footer>
<p>
© 2024 Math Coding Camp - EPPS
</p>
<p>
Made with ❤️ by <a href="https://github.com/shreyasmeher" target="_blank" rel="noopener noreferrer">Shreyas Meher</a>
</p>
</footer>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>